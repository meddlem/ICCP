\chapter{The magic of Makefiles}
\label{chap:Makefiles}

\begin{quote}
  \begin{verbatim}
love: /dev/null
  @echo not war
  \end{verbatim}
\end{quote}

Once your programs become larger, it is convenient to split the source code into several files.
However, to obtain a running program, each of these files has to be compiled separately (resulting in a \emph{relocatable object file}, with extension \texttt{.o}) and then combined (linked) into a single program.
Doing this by hand quickly becomes tedious, so we resort to using Makefiles.
We create a file called \texttt{Makefile} that contains all compiler invocations, and then we can compile the program by simply typing
\begin{verbatim}
$ make
\end{verbatim}
Similarly, we can remove all compiler-generated files with
\begin{verbatim}
$ make clean
\end{verbatim}
The \texttt{make} program is smart enough to only compile files that have changed; so if you just fixed a bug in \texttt{file6.f90}, it will only recompile that file (generating \texttt{file6.o}) and perform the linking step, without touching the other files.

\lstinputlisting[language=,showtabs=true,float=htb,label=lst:example_makefile]{examples/example_makefile}
So, what does a \texttt{Makefile} look like? As an example, let's go through \cref{lst:example_makefile} step by step.
\begin{itemize}
  \item The first lines declare a few variables for later use.
    \texttt{FC} is set to the Fortran compiler \texttt{gfortran}, \texttt{FFLAGS} contains the compiler flags and \texttt{LDFLAGS} the linker flags.
    The \texttt{COMPILE} and \texttt{LINK} variables combine these to get the compile and link commands.
  \item Most non-trivial programs make use of several function libraries, such as the Linear Algebra PACKage (LAPACK).
    These libraries are stored under \texttt{/usr/lib} and have filenames such as \texttt{liblapack.a} or \texttt{liblapack.so}.
    You can link such a library with your program by specifying the \texttt{-llapack}\index{LAPACK!linking} argument to the linker.
    Note that you have to omit both \texttt{lib} and the extension (\texttt{.a} or \texttt{.so}) from the library name.
    Since libraries have to appear after the object files for the linker, they are specified in the separate variable \texttt{LIBS}.
    If the library cannot be found in the system paths, you can tell the compiler to search for it in the directory \texttt{\emph{PATH}} by adding the option \texttt{-L\emph{PATH}} to \texttt{LDFLAGS}, \eg, \texttt{LDFLAGS = -L\$HOME/mylib}.
  \item Makefiles are built around rules, which have the form `\texttt{\emph{target}: \emph{dependencies}}' followed by lines with rules to create the target from the dependencies\footnote{You \emph{must} indent lines containing rules with a tab character, not spaces! \Cref{lst:example_makefile} represents tabs with a wide underscore for easy identification.}.
    Except for a few special targets, such as \texttt{all} and \texttt{clean}, \texttt{make} will assume the target is a file, and try to recreate it if the target is older than the dependencies.
  \item If \texttt{make} is invoked without any parameters, the default target is the first entry in the \texttt{Makefile} (in this case \texttt{all}), which depends on \texttt{myprog} here.
    \texttt{myprog} in turn depends on the list of object files in \texttt{\$(OBJS)}.
    This is the reason we only specified the object files and not the source code files.
    The executable is generated by invoking the linker, which combines the object files with the external libraries.
    In the \texttt{Makefile}, \texttt{\$@} is an alias for the target.
    On line 17, for example, \texttt{\$@} is replaced by \texttt{myprog} when running \texttt{make}.
    Similarly, \texttt{\$\^} is an alias for all dependencies, in this case the list \texttt{\$(OBJS)}.
  \item
    \begin{margintable}[11.2\baselineskip]
      \begin{tabular}{ll}
        \toprule
        Sigil & Meaning \\
        \midrule
        \texttt{\$@} & Target filename \\
        \texttt{\$<} & First prerequisite\\
        \texttt{\$\^} & All prerequisites \\
        \texttt{\$?} & All newer prerequisites\\
        \texttt{\%} & Wildcard (usually)\\
        \bottomrule
      \end{tabular}
      \caption{Reference table for common makefile sigils.}
    \end{margintable} 
    Since we don't want to specify a separate rule for every object file, we use \emph{wildcards}.
    \texttt{\%.o: \%.f90} means every object file ending in \texttt{.o} depends on the corresponding source file, ending in \texttt{.f90}.
    \texttt{\$<} on the command line is an alias for the first prerequisite, in this case the source file.
    The \texttt{-c} option tell the compiler to only perform the compilation step to create an object file, and to skip linking.
    Note that the object files are compiled in the order specified in \texttt{\$(OBJS)}.
    This means that if the program file \texttt{myprog} depends on the module \texttt{mymod}, \texttt{mymod.o} needs to be listed before \texttt{myprog.o}.
  \item The special target \texttt{clean}\marginnote{\texttt{clean} has also been designated as \texttt{PHONY}. The \texttt{make} program will never check to see if a phony target actually exists, it will always just execute the rule.} is used to delete all compiler-generated files.
    This includes the executable \texttt{myprog}, the object files listed in \texttt{\$(OBJS)} and any automatically generated module files (with extension \texttt{.mod}).
\end{itemize}
In the rest of these notes we will assume that you have created a \texttt{Makefile} for each project based on this template.
